<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Harry Whelchel]]></title><description><![CDATA[Ruby, Javascript, and More.]]></description><link>http://127.0.0.1:2368/</link><generator>Ghost 0.6</generator><lastBuildDate>Sun, 30 Aug 2015 19:20:11 GMT</lastBuildDate><atom:link href="http://127.0.0.1:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Warden - A Review]]></title><description><![CDATA[<p><a href="https://github.com/hassox/warden">Warden</a> is a simple and powerful authentication mechanism for <a href="https://github.com/rack/rack">rack</a> based ruby applications. Using a rack middleware, it injects an object into the rack environment which can be used to authenticate incoming requests.</p>

<p>At its core, Warden uses 'manager', 'proxy', and 'strategy' abstractions to accomplish its goals. The library shines</p>]]></description><link>http://127.0.0.1:2368/a-review-warden/</link><guid isPermaLink="false">be8030ae-da3b-4371-8a75-44feddc26e53</guid><dc:creator><![CDATA[Harry Whelchel]]></dc:creator><pubDate>Sun, 30 Aug 2015 19:04:01 GMT</pubDate><content:encoded><![CDATA[<p><a href="https://github.com/hassox/warden">Warden</a> is a simple and powerful authentication mechanism for <a href="https://github.com/rack/rack">rack</a> based ruby applications. Using a rack middleware, it injects an object into the rack environment which can be used to authenticate incoming requests.</p>

<p>At its core, Warden uses 'manager', 'proxy', and 'strategy' abstractions to accomplish its goals. The library shines in its implementation of the strategy pattern -- allowing for imaginative and unplanned authentication mechanisms. The manager highlights the power and simplicity of web middlewares as it injects the authentication object into the rack environment. Finally the proxy serves as the authentication strategies' context running them lazily on demand.</p>

<p>The authors' chosen abstractions map well to the problem domain -- however even greater clarity and robustness in design can be achieved through extracting responsiblities of the proxy and manager and through a greater use of dependency injection.</p>

<h2 id="termstoknow">Terms to Know</h2>

<ul>
<li><strong>Strategy</strong> a pattern for when you have a clear task to accomplish, but more than one way to do it.</li>
<li><strong>Virtual Proxy</strong> a pattern for delaying creation of an object until it is needed.</li>
<li><strong>Rack Middlware</strong> a minimal interface for ruby webservers. Imagine the web request moves through a pipe and each section of pipe is a middleware.</li>
<li><strong>Extensibility</strong> is the ease at which new implementations (how something is accomplished) can be introduced while maintaining the existing interface (what is accomplished)</li>
<li><strong>Composition</strong> a recognition of distinct concepts that make up a larger whole. A classic example is the car composed of wheels, engine, brakes, and more.</li>
<li><strong>Single Responsiblity Principle</strong> states an object should only have "one reason to change" decoupling the actors in the system.</li>
<li><strong>Dependency Inversion</strong> highlights the benefit of depending on abstractions over concretions -- both for higher level and low level concerns. If both high level and low level concepts depend on abstract interfaces then high level concepts achieve greater independence from low level concerns.</li>
</ul>

<h2 id="thestrategy">The Strategy</h2>

<p>Warden strategies are responsible for housing specific authentication logic such as checking a username and password against a database or checking for the presence of a "remember me" cookie. Warden does not come with any concrete strategies -- only a <a href="https://github.com/hassox/warden/blob/v1.2.3/lib/warden/strategies/base.rb">base class</a> that defines the required api. The strategy class is the strongest element of the library due to the extensibility and composability it brings.</p>

<p>Valid strategies must only implement <code>authenticate!</code> and optionally <code>valid?</code>. Because the public api is only one method, developers can easily implement their own strategies to fit their authentication needs.</p>

<p><a href="https://github.com/hassox/warden/blob/v1.2.3/lib/warden/proxy.rb#L337-L356">Snippet Source</a></p>

<pre><code class="language-ruby">  def _run_strategies_for(scope, args)
    # ... omitted code

  (strategies || args).each do |name|
    strategy = _fetch_strategy(name, scope)
    next unless strategy &amp;&amp; !strategy.performed? &amp;&amp; strategy.valid?

    strategy._run! # this calls the underlying authenticate!
  end

  # ... omitted code
end  
</code></pre>

<p>The strategy builds on the value of composition by recognizing that often a particular task must be accomplished by an actor in the system, but there are numerous ways to accomplish the task. Therefore the mechanism of accomplishing a task is separated and abstracted from <a href="https://github.com/hassox/warden/blob/v1.2.3/lib/warden/proxy.rb#L337">the actor</a>. In this way the actor looses knowledge (a good thing!) of how it accomplishes its task while still getting the job done.</p>

<h2 id="themanager">The Manager</h2>

<p><a href="https://github.com/hassox/warden/blob/v1.2.3/lib/warden/manager.rb">Warden's manager</a> is responsible for managing the library's lifecycle from injecting the authentication object to handling failed requests. The strength of the <a href="https://github.com/hassox/warden/blob/v1.2.3/lib/warden/manager.rb#L34-L36">middleware pattern</a> should be noted as it creates a pipeline of logic which can modify a web request as it enters the web server and can modify the response as it leaves. Despite the elegance of the middleware pattern the manager does not feel as focused or general as it could be.</p>

<p>In my analysis I identified four responsibilities of the manager. It <a href="https://github.com/hassox/warden/blob/v1.2.3/lib/warden/manager.rb#L33">injects the authentication object</a>, <a href="https://github.com/hassox/warden/blob/v1.2.3/lib/warden/manager.rb#L41-L47">handles failed requests</a>, <a href="https://github.com/hassox/warden/blob/v1.2.3/lib/warden/manager.rb#L52-L54">runs the callback lifecycle</a>, <a href="https://github.com/hassox/warden/blob/v1.2.3/lib/warden/manager.rb#L21">handles library configuration</a>, and provides methods for <a href="https://github.com/hassox/warden/blob/v1.2.3/lib/warden/manager.rb#L56-L88">user deserialization and serialization configuration</a>.</p>

<p>The manager would benefit from a <code>UserProxy</code>responsible for configuration and implementing user session (de)serialization. It would also benefit from an <code>UnauthenticatedResponse</code> which would process unauthenticated requests routing them to a redirect, custom response, or the failure app. Through the addition of these classes, the manager would become solely responsible for coordinating the authentication logic amongst these objects.</p>

<p><a href="https://github.com/hassox/warden/blob/v1.2.3/lib/warden/manager.rb#L123-L134">Snippet Source</a></p>

<pre><code class="language-ruby">def call_failure_app(env, options = {})  
  if config.failure_app
    options.merge!(:attempted_path =&gt; ::Rack::Request.new(env).fullpath) # Concrete Request
    env["warden.options"] = options
    # ... omitted code

    config.failure_app.call(env).to_a
  else
    # ... omitted code
  end
end  
</code></pre>

<p>In the manager the config, proxy, and rack request are all instantiated by the manager internally. As a result the manager is coupled to these specific objects. If instead these objects were injected at initialization of the manager or through a method call, the manager would no longer be concerned with the type of the object but only whether it can respond to the necessary messages.</p>

<p><a href="https://github.com/hassox/warden/blob/v1.2.3/lib/warden/manager.rb#L30-L49">Snippet Source</a></p>

<pre><code class="language-ruby">def call(env) # :nodoc:  
  # ... omitted code

  env['warden'] = Proxy.new(env, self) # Concrete Proxy
  result = catch(:warden) do
    @app.call(env) # Abstract app and env
  end

  # ... omitted code
end  
</code></pre>

<p>Despite the multiple responsibilities and concrete dependencies the manager does a great job with the injection of the app and env as abstractions--a middleware requirement.</p>

<h2 id="theproxy">The Proxy</h2>

<p>The proxy is a virtual proxy to a number of objects most importantly the hash of authentication strategies. The laziness of the proxy is a very nice design choice, improving application performance, while introducing limited complexity in the code. However the proxy also suffers from numerous responsibilities and reliance on concretions.</p>

<p><a href="https://github.com/hassox/warden/blob/v1.2.3/lib/warden/proxy.rb">The proxy</a> does a lot and has access to a lot. It <a href="https://github.com/hassox/warden/blob/v1.2.3/lib/warden/proxy.rb#L360-L368">lookups the strategies</a>, <a href="https://github.com/hassox/warden/blob/v1.2.3/lib/warden/proxy.rb#L30">caches the strategies</a>, <a href="https://github.com/hassox/warden/blob/v1.2.3/lib/warden/proxy.rb#L337-L356">runs the authentication strategies</a>, provides access to warden <a href="https://github.com/hassox/warden/blob/v1.2.3/lib/warden/proxy.rb#L36-L38">errors</a>, allows <a href="https://github.com/hassox/warden/blob/v1.2.3/lib/warden/proxy.rb#L205-L219">reading</a>, <a href="https://github.com/hassox/warden/blob/v1.2.3/lib/warden/proxy.rb#L164-L182">writing</a>, <a href="https://github.com/hassox/warden/blob/v1.2.3/lib/warden/proxy.rb#L254-L269">deletion</a> of the user from the session, and <a href="https://github.com/hassox/warden/blob/v1.2.3/lib/warden/proxy.rb#L329-L334">manages authentication scopes</a>. Many of these responsibilities are facilitated by the <a href="https://github.com/hassox/warden/blob/v1.2.3/lib/warden/proxy.rb#L27-L32">initialization</a> of the proxy with the rack env, manager, and config stored in instance variables.</p>

<p>The proxy could benefit from an <code>Authenticator</code> that runs the strategies, a <code>StrategyCache</code> that lookups and caches the strategies, a <code>UserProxy</code> for higher level read, write, delete access to the user in the session, <code>ScopeManager</code> which would manage the authentication scopes and their config. The introduction of a few additional objects would do a lot to simplify the complexity of the class.</p>

<p><a href="https://github.com/hassox/warden/blob/v1.2.3/lib/warden/proxy.rb#L27-L46">Snippet Source</a></p>

<pre><code class="language-ruby"># Abstract
def initialize(env, manager)  
  @env, @users, @winning_strategies, @locked = env, {}, {}, false
  @manager, @config = manager, manager.config.dup
  @strategies = Hash.new { |h,k| h[k] = {} }
  manager._run_callbacks(:on_request, self)
end

# Concrete
def errors  
  @env[ENV_WARDEN_ERRORS] ||= Errors.new
end

def session_serializer  
  @session_serializer ||= Warden::SessionSerializer.new(@env)
end  
</code></pre>

<p>The proxy is also dogged by a few concrete dependencies. The errors and session serializer could be injected making this code more extensible. However the proxy also benefits from the presence of abstract manager and env dependencies.</p>

<h2 id="close">Close</h2>

<p>As an everyday user of <a href="https://github.com/plataformatec/devise">Devise</a> I love the simple and extendable authentication mechanism Warden offers. Warden not only is easy to use it is a fun read and provides excellent case studies in the strategy pattern, middleware pattern, and proxy. If you are interested in learning more I would encourage you to look at Devise's use of Warden. There you will see a mature implementation of the library with <a href="https://github.com/plataformatec/devise/tree/v3.4.1/lib/devise/strategies">multiple sophisticated strategies</a>.</p>

<p><em>Thank you to Steve Bussey for feedback on a draft of this post.</em></p>]]></content:encoded></item><item><title><![CDATA[Streams in JavaScript]]></title><description><![CDATA[<p><em>Time is but the stream I go a-fishing in.</em></p>

<p>-Henry David Thoreau</p>

<p>Recently I was rereading <a href="http://mitpress.mit.edu/sicp/full-text/book/book.html">Structure and Interpretation of Computer Programs</a> by Abelson and Sussman and was hooked by the section on streams. Streams allow one to reason about stateful phenomena while mitigating "some of the complexities of modeling</p>]]></description><link>http://127.0.0.1:2368/streams-in-javascript/</link><guid isPermaLink="false">603f9b69-0e0f-4ef2-93c4-3326750cc1de</guid><dc:creator><![CDATA[Harry Whelchel]]></dc:creator><pubDate>Sun, 18 May 2014 02:23:40 GMT</pubDate><content:encoded><![CDATA[<p><em>Time is but the stream I go a-fishing in.</em></p>

<p>-Henry David Thoreau</p>

<p>Recently I was rereading <a href="http://mitpress.mit.edu/sicp/full-text/book/book.html">Structure and Interpretation of Computer Programs</a> by Abelson and Sussman and was hooked by the section on streams. Streams allow one to reason about stateful phenomena while mitigating "some of the complexities of modeling state".  </p>

<p>A stream is a data structure representing the history of values for a system across time. Imagine physics' <a href="http://en.wikipedia.org/wiki/World_line">world line</a> concept applied to any system or phenomena. If one thinks about the life of an apple over time it ages. But if one considers the entire history of the apple through time that function is constant with respect to time. I decided it would be fun to implement this concept in JavaScript.</p>

<h4 id="implementation">Implementation</h4>

<p>To easily model a stream implement it as a delayed list. This means the <strong>head</strong> of the list will be the current value and the <strong>tail</strong> will be a <strong>promise</strong> to evaluate the next element in the stream. In SICP the authors use the delay method to convert a tail into a promise and then use the force method to evaluate the promise.</p>

<pre><code>function Stream(head, tail) {  
    this.headValue = head;
    this.tailValue = this.delay(tail);
}

Stream.prototype = {  
  delay: function(tail) {
    return tail();
  },
  force: function(delayedTail){
    return delayedTail();
  }
}
</code></pre>

<h4 id="application">Application</h4>

<p>Because streams are sequences we can still use sequence methods like enumerating, filtering, accumulating, and mapping but because streams delay evaluation we can perform these manipulations on sequences that are large or infinite in size. </p>

<p>For example I can take a stream representing all integers beginning with the number 2 and run it through the Sieve of Eratosthenes to generate a stream of the prime numbers.</p>

<pre><code>Stream.integersStartingFrom = function(num) {  
  return new Stream(num, function(){
    return integersStartingFrom(num += 1);
  });
};
Stream.prototype.sieve = function() {  
    var self = this;
    return new Stream(self.head(), function() {
      return self.tail().filter(function(num) {
        return !willDivide(self.head(), num);
        }).sieve();
    });
  }

var primes = Stream.integersStartingFrom(2).sieve();  
console.log(primes.item(50)); // 233  
</code></pre>

<p>Streams allow the developer to cleanly separate and intuitively reason about these types of tasks across data collections.</p>

<h4 id="improvements">Improvements</h4>

<p>One early improvement to make in a streams library is to memoize the delay method that generates the promise. Rather than reevaluating the tail everytime use a closure to store whether the tail has been evaluated in the past and if so return that result.</p>

<pre><code>Stream.prototype = {

 delay: function(tail) {
    return this._memoTail(tail);
  },

  _memoTail: function(tail){
    var hasRun = false;
    var result;
    return function(){
      if(!hasRun) {
        result = tail();
        hasRun = true;
        return result;
      } else {
        return result;
      }
    };
  }
}
</code></pre>

<h4 id="practicalusecases">Practical use cases</h4>

<p>Infinite streams of data can be found in many fields from physics, finance, and engineering. In physics as mentioned the world line is the concept of reasoning about an elements' entire history through spacetime. In finance there are many financial assets that exhibit stream like behavior such as <a href="http://en.wikipedia.org/wiki/Perpetuity">perpetuities</a> and <a href="http://en.wikipedia.org/wiki/Market_data">stock market data</a>. In engineering they can be found in the <a href="http://en.wikipedia.org/wiki/Fourier_series">fourier series</a> which has application in electrical engineering, optics, acoustics, and more.</p>

<h4 id="nextsteps">Next steps</h4>

<p>I would like to explore using the stream data structure to model some of the practical applications listed above namely the modeling of financial streams and fourier series.</p>

<h4 id="thecode">The code</h4>

<p>The full code used can be found on my github in the <a href="https://github.com/hwhelchel/streams">streams</a> repository. I would also like to mention the <a href="https://github.com/dionyziz/stream.js">streams.js</a> library by dionyziz which helped jump start my implementation of streams in JavaScript.</p>]]></content:encoded></item><item><title><![CDATA[Recursion in Ruby]]></title><description><![CDATA[<p>Studying Ruby and object oriented programming at Dev Bootcamp we have been working with exercises that lend themselves to recursive thinking. Because recursion was challenging yet often elegant I researched the subject further in the context of the Ruby language. For more here is an excellent resource on <a href="http://kaibun.net/blog/2010/03/17/simple-thought-about-recursion-in-Ruby/">recursion in</a></p>]]></description><link>http://127.0.0.1:2368/recursion-in-ruby/</link><guid isPermaLink="false">e195f71d-3ccc-4830-9006-fd2aafa6954b</guid><dc:creator><![CDATA[Harry Whelchel]]></dc:creator><pubDate>Sun, 18 May 2014 01:02:44 GMT</pubDate><content:encoded><![CDATA[<p>Studying Ruby and object oriented programming at Dev Bootcamp we have been working with exercises that lend themselves to recursive thinking. Because recursion was challenging yet often elegant I researched the subject further in the context of the Ruby language. For more here is an excellent resource on <a href="http://kaibun.net/blog/2010/03/17/simple-thought-about-recursion-in-Ruby/">recursion in Ruby</a> by Jean-Denis Vauguet.</p>

<h2 id="whatisrecursion">What is Recursion?</h2>

<p>Recursion is a method of solving problems by dividing them into the same problem of a smaller size. A recursive method calls itself a certain number of times. It is commonly found in functional languages however imperative languages such as Ruby can make use of recursive algorithms.</p>

<p>Perhaps surprisingly all iterations can be written recursively. Loops that rely on while or until are often intuitive candidates. The while or until loop condition can often be coerced into a recursive base case.</p>

<h4 id="thebasecase">The Base Case</h4>

<p>The key to recursion is limiting the number of method self-calls. To limit the number of calls we must establish a base case. When the base case has been reached the method stops calling itself and begins returning up the chain of method calls.</p>

<h2 id="considerationsforrecursioninruby">Considerations for Recursion in Ruby</h2>

<p>Recursion in Ruby and most imperative languages is considered inefficient. Because almost everything is an object in Ruby, repeated object instantiation can arise in recursive calls, leading to reduced speed. Furthermore additional stack frames are required for each method call's arguments and local variables. Too many recursive calls can lead to stack overflow induced crashes. Tail Call Recursion and Memoization can help reduce the risk of stack overflow. </p>

<h4 id="tailcalloptimization">Tail Call Optimization</h4>

<p>Tail Call Optimization allows recursive method calls without the allocation of additional memory on the stack. Simply put the calling method returns the value it gets from the called method. Therefore recursive methods are implemented in constant stack space eliminating the risk of stack overflow.</p>

<h4 id="memoization">Memoization</h4>

<p>Memoization of a method eliminates repeat calculations of results for prior inputs. A memoized method has a lookup table of prior inputs and outputs that it can use to speed up future calls for new inputs. With the added lookup table, memoization lowers a method's time cost at the expense of added space cost. If methods are well-defined, i.e. they consistently return the same output for given arguments, then this can be an effective tool to reduce the risk of stack overflow.</p>

<h2 id="bogglerecursionexample">Boggle: Recursion Example</h2>

<p>Below is a program the generates a random boggle board. It then takes a string from the user and returns true if the string is made of sequentially adjacent dice, whether they are horizontally, diagonally, or vertically neighboring. Using recursion, BoggleBoard#include? takes the first letter of the user's string and then traverses all possible paths from the occurrences of the letter on the board looking for a match.</p>

<pre><code class=" ruby">class BoggleBoard

  attr_accessor :board

  DICE = [
          ["A", "A", "E", "E", "G", "N"],
          ["A", "B", "B", "J", "O", "O"],
          ["A", "C", "H", "O", "P", "S"],
          ["A", "F", "F", "K", "P", "S"],
          ["A", "O", "O", "T", "T", "W"],
          ["C", "I", "M", "O", "T", "V"],
          ["D", "E", "I", "L", "R", "X"],
          ["H", "L", "N", "N", "R", "Z"],
          ["D", "I", "S", "T", "T", "Y"],
          ["E", "E", "G", "H", "N", "W"],
          ["E", "E", "I", "N", "S", "U"],
          ["E", "H", "R", "T", "V", "W"],
          ["E", "I", "O", "S", "S", "T"],
          ["E", "L", "R", "T", "T", "Y"],
          ["H", "A", "E", "E", "G", "N"],
          ["A", "I", "M", "N", "Q", "U"]
        ]

  def initialize
    @board = []
    @shake_counter = 0
  end

  def shake!
    @board = []

    DICE.each do |die|
      @board &lt;&lt; Node.new(die.sample)
    end

    @shake_counter += 1
    populate_neighbors
    display

  end

  def display
    @board.each_slice(4) do |slice|
      slice.each do |node|
        print node.value
      end
      puts ""
   end
  end

  # Generate neighbors for each dice in the board.
  def populate_neighbors
    @board.each_with_index do |node, node_index|
      node.neighbors &lt;&lt; @board[node_index + 1] unless node_index % 4 == 3 # right neighbor
      node.neighbors &lt;&lt; @board[node_index - 1] unless node_index % 4 == 0 #left neighbor
      node.neighbors &lt;&lt; @board[node_index + 4] unless node_index &gt; 11 #bottom neighbor
      node.neighbors &lt;&lt; @board[node_index - 4] unless node_index &lt; 4 #top neighbor etc...
      node.neighbors &lt;&lt; @board[node_index - 3] unless (node_index % 4 == 3) || (node_index &lt; 4) #top right
      node.neighbors &lt;&lt; @board[node_index + 3] unless (node_index % 4 == 0) || (node_index &gt; 11) # bottom left
      node.neighbors &lt;&lt; @board[node_index + 5] unless (node_index % 4 == 3) || (node_index &gt; 11) # bottom right
      node.neighbors &lt;&lt; @board[node_index - 5] unless (node_index % 4 == 0) || (node_index &lt; 4) # top left
    end
  end

  # Traverse possible paths that may match the user's input.
  def include?(string, root = nil, used = [])
    string.upcase!
    used == [] ? paths = @board : paths = root.neighbors
    paths.each do |node| # First time look at the entire board. Next time node children.
      if (node.value == string[0]) &amp;&amp; !used.include?(node)
        used &lt;&lt; node
        return true if string == node.value # Base Case
        return include?(string[1..-1], node, used) # Recursion
      end
      used = []
    end

    return false

  end

end


class Node

  attr_accessor :neighbors, :value

  def initialize(letter)
    @value = letter
    @neighbors = []
  end

end

OurBoard = BoggleBoard.new()  
OurBoard.shake!

puts "==============================="

end_program = ""  
until end_program == "quit"  
  puts "please enter a string to search for"
  end_program = gets.chomp!
  if OurBoard.include?(end_program) == true
    p true
  else
    return end_program
  end
end  
</code></pre>]]></content:encoded></item><item><title><![CDATA[Sorting Algorithms in Ruby]]></title><description><![CDATA[<p>Having enjoyed excellent posts on sorting algorithms I wanted to share my implementation of common sorting algorithms in Ruby. There are some great <a href="http://www.sorting-algorithms.com">visualizations of sorting algorithms</a> especially on Mike Bostock's blog such as the <a href="http://bost.ocks.org/mike/shuffle/">Fisher-Yates Shuffle</a>, <a href="http://bl.ocks.org/mbostock/1243323">merge sort</a>, and <a href="http://bl.ocks.org/mbostock/1582075">quick sort</a>. Taking a leaf out of Jesse La Russo's</p>]]></description><link>http://127.0.0.1:2368/sorting-algorithms-in-ruby/</link><guid isPermaLink="false">582c4890-87fa-42ab-9b83-0e00cbf2f113</guid><dc:creator><![CDATA[Harry Whelchel]]></dc:creator><pubDate>Sun, 18 May 2014 01:02:35 GMT</pubDate><content:encoded><![CDATA[<p>Having enjoyed excellent posts on sorting algorithms I wanted to share my implementation of common sorting algorithms in Ruby. There are some great <a href="http://www.sorting-algorithms.com">visualizations of sorting algorithms</a> especially on Mike Bostock's blog such as the <a href="http://bost.ocks.org/mike/shuffle/">Fisher-Yates Shuffle</a>, <a href="http://bl.ocks.org/mbostock/1243323">merge sort</a>, and <a href="http://bl.ocks.org/mbostock/1582075">quick sort</a>. Taking a leaf out of Jesse La Russo's <a href="http://jlarusso.github.io/blog/2013/04/30/sorting-algorithms-in-ruby/">blog</a> below are my implementations of common sorting algorithms in Ruby.</p>

<h3 id="insertionsort">Insertion Sort</h3>

<ol>
<li>Begin at the second element. Compare the element to the element prior. Swap if less than the element prior.</li>
<li>Increment by one element. Compare this element to prior two elements. Insert accordingly.</li>
<li>Continue incrementing by one element and comparing that element to all prior sorted elements until the list is fully sorted.</li>
</ol>

<pre><code class=" ruby">def insertion_sort(list)  
  (1...list.length).each do |i| 
      k = i
      while k &gt; 0 &amp;&amp; list[k] &lt; list[k-1]
        list[k], list[k-1] = list[k-1], list[k]
        k -= 1
      end
  end
  list
end  
</code></pre>

<h3 id="selectionsort">Selection Sort</h3>

<ol>
<li>Start at first element of unsorted list. Look for the smallest element in the list. Swap with left most unsorted element. </li>
<li>Move to the second element. Swap with smallest element of this unsorted list.</li>
</ol>

<pre><code class="ruby">def selection_sort(list)  
  (0...list.length).each do |i|
    k = i

    (i+1...list.length).each do |j|
      k = j if list[j] &lt; list[k]
    end

    if k != i
      list[i],list[k] = list[k],list[i] 
    end
  end
  list
end  
</code></pre>

<h3 id="bubblesort">Bubble Sort</h3>

<ol>
<li>Start at first element. Compare adjacent pairs. Swap if out of order.</li>
<li>Iterate through the list repeatedly. Each iteration requires one less comparison.</li>
</ol>

<pre><code class="ruby">def bubble_sort(list)  
  begin

    swapped = false
    (1...list.length).each do |i|

      if list[i] &lt; list[i-1]
        list[i], list[i-1] = list[i-1],list[i]
        swapped = true
      end

    end

  end until !swapped
  list
end  
</code></pre>

<h3 id="shellsort">Shell Sort</h3>

<p>(Insertion sort on sublists or sublists of elements allowing swap of elements far apart.)  </p>

<ol>
<li>Determine sublists by splitting the list in half repeatedly.</li>
<li>Insertion sort of the elements in each sublist.</li>
<li>When the sublist is one or zero elements long then the list is sorted.</li>
</ol>

<pre><code class="ruby">def shell_sort(list)  
  gap = list.length/2
  while gap &gt; 0

    # Insertion Sort
    (gap...list.length).each do |i|
      k = i
      while k &gt;= gap &amp;&amp; list[k] &lt; list[k-gap]
        list[k], list[k-gap] = list[k-gap], list[k]
        k -= gap
      end
    end

    gap /= 2
  end
  list
end  
</code></pre>

<h3 id="mergesort">Merge Sort</h3>

<ol>
<li>Divide the unsorted list into sublists around a pivot.</li>
<li>Recursively call merge sort on the sublists.</li>
<li>Merge the results of the recursive calls.</li>
</ol>

<pre><code class="ruby">def merge_sort(list)  
  return list if list.length &lt;= 1
  left = []
  right = []
  pivot = list.length / 2

  list.each_with_index do |e,i|
    left &lt;&lt; e if i &lt; pivot
  end

  list.each_with_index do |e,i|
    right &lt;&lt; e if i &gt;= pivot
  end

  left = merge_sort(left)
  right = merge_sort(right)

  merge(left, right)
end

def merge(left, right)  
  result = []
  while left.length &gt; 0 || right.length &gt; 0
    if left.length &gt; 0 &amp;&amp; right.length &gt; 0
      result &lt;&lt; (left[0] &lt;= right[0] ? left.shift : right.shift)
    elsif left.length &gt; 0
      result &lt;&lt; left.shift
    else
      result &lt;&lt; right.shift
    end
  end
  result
end  
</code></pre>

<h3 id="heapsort">Heap Sort</h3>

<ol>
<li>Build a heap out of the data. The heap is a tree data structure where the parent node is always greater than or equal to its child nodes across the entire heap. </li>
<li>Remove the root of the heap and insert in sorted array. Reconstruct heap and repeat.</li>
</ol>

<pre><code>def heap_sort(list)  
  count = list.length

  heapify(list, count)

  last = count - 1
  while last &gt; 0
    p "#{list[last]}, #{list[0]}"
    list[last], list[0] = list[0], list[last]
    last -= 1
    sift_down(list,0,last)
  end

  list
end

def heapify(list, count)  
  start = (count - 2) / 2

  while start &gt;= 0
    sift_down(list,start,count-1)
    start -= 1
  end
end

def sift_down(list, start, last)  
  root = start

  while root * 2 + 1 &lt;= last
    child = root * 2 + 1
    swap = root

    swap = child if list[swap] &lt; list[child]
    if child + 1 &lt;= last &amp;&amp; list[swap] &lt; list[child+1]
      swap = child + 1 
    end
    if swap != root
      list[root], list[swap] = list[swap], list[root]
      root = swap
    else
      return
    end
  end
end  
</code></pre>

<h3 id="quicksort">Quick Sort</h3>

<ol>
<li>Divide list into two smaller lists.</li>
<li>Pick a pivot. </li>
<li>Reorder list so that all elements less than the pivot come before it and all elements greater than the pivot come after it. </li>
<li>Recursively apply steps 2 and 3 to the sublists until base case of size 0 or 1 lists is reached.</li>
</ol>

<pre><code>def quick_sort(list)

  return list if list.length &lt;= 1

  pivot = list[list.length/2]

  less, greater = list.partition {|e| e &lt; pivot}

  quick_sort(less) + [pivot] + quick_sort(greater)

end  
</code></pre>]]></content:encoded></item></channel></rss>